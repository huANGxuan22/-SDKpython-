

开发前需要先前往官网了解该相机是否支持MVS工具，大部分MV开头的产品都支持MVS工具，但其余型号的相机不一定支持，需要前往官网[Search - 海康威视 Hikvision](https://www.hikvision.com/cn/search/?q=%E7%9B%B8%E6%9C%BA+mv-ca060-10gc%E5%B7%A5%E4%B8%9A%E7%9B%B8%E6%9C%BA&active=%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%B7%A5%E5%85%B7)查看该设备是否支持，支持的设备和不支持的设备开发模式是不一样的。

**下面先说不支持的设备**

对于不支持的设备需要用到海康的设备网络SDK或者其他支持的SDK

这里我是用的设备网络SDK下载地址[海康开放平台](#%E8%AE%BE%E5%A4%87%E9%9B%86%E6%88%90SDK)

由于海康并没有提供python的SDK所以需要使用python中的ctypes库来对C++的SDK库进行引用。

使用SDK开发的基本流程如下：

![[Pasted image 20251103171754.png]]


+ #第一步，登录设备

以公司的设备为例，公司提供的设备在连接网线时可以用http://192.168.110.110/直接访问，连接路由器后会被端口映射，这时可以通过地址为172.31.16.15访问（注意，不建议在这种情况下开发，因为这会导致登录的时候不清楚端口号被映射到什么地方）。

如若不知道设备的IP地址可以通过海康官方的设备网络搜索工具查看下载地址[SADP - HiTools - Hikvision Global](https://www.hikvision.com/en/support/tools/hitools/clea8b3e4ea7da90a9/)

关于浏览器，由于公司提供的设备较老，推荐使用IE进行设备登录，如若没有IE可以使用Edge登录（其实其他浏览器也可以登录，只是没办法正常预览），使用Edge浏览器需要进行设置，如下：
![[Pasted image 20251103171847.jpg]]
 

如图，在设置中点击默认浏览器页面，然后在IE模式页面中添加设备网址即可，在成功登陆后使用预览功能需要下载插件，正常下载然后启用就可以了。

遇到无法正常登录的情况可能是电脑网段与设备不在同一网段内，进行配置即可。

+ #第二部份，开发准备

接下来便可以进行SDK开发了，在[海康开放平台](#%E8%AE%BE%E5%A4%87%E9%9B%86%E6%88%90SDK)下载对应版本的SDK（我测试时主要使用的WIN64）但实际体验下来各个版本的差别不大，连官方文档也没有对不同版本之间的详细区分，只是在开发过程中调用的部分库不同。

文件结构（仅供参考）：

![[image/Pasted image 20251103171851.jpg]]

其中dll中放的是SDK中的库文件

![[image/Pasted image 20251103171853.jpg]] 

其余的都是一些我自己搞的文件
接下来就是使用ctypes库引入海康SDK


```python
from ctypes import *
 
 
class HkAdapter:
    dll_path = r"D:\Backup\solo\hkoython\dll"
 
    def load_hkdll(self):
        # 载入HCCore.dll
        Hccode_py = WinDLL(__class__.dll_path + "\\HCCore.dll")
        # 载入HCNetSDK.dll
        Hcnetsdk_py = cdll.LoadLibrary(__class__.dll_path + "\\HCNetSDK.dll")
        return hcnetsdk
```


后面就可以通过Hccode_py，Hcnetsdk_py来访问其中的函数了。

[注意，HCCore.dll和HCNet.dll是必须引入的，其他动态链接库虽然不必要但是建议一起放入dll文件夹中对于海康提供的库文件中的HCNetSDKCom文件夹也是必须的，不要改名或是移动文件位置。]

引入了这两个动态链接库之后就已经可以使用大部分基础功能了，下面进行示例。
- 对于没有参数的函数
```python
def init(Hksdk_py):
    if not Hccode_py.NET_DVR_Init():
        print("初始失败")
        return False
    if not Hcnetsdk_py.NET_DVR_SetConnectTime():
        print("设置连接时间失败")
        return False
    print("初始化成功")
    return True
```

其中NEt_DVR_Init() 和NET_DVR_SetConnectTime()是初始化函数，没有参数传入，直接使用Hccode_py.NET_DVR_Init()就可以访问。

- 对于需要参数的函数，以登录为例
在C++中登录如下
```C++
    NET_DVR_USER_LOGIN_INFO loginInfo = { 0 };
	NET_DVR_DEVICEINFO_V40 deviceInfo = { 0 };
 
	//登录方式设置为同步
	loginInfo.bUseAsynLogin = 0;
 
	const char *deviceAddress, *userName, *passWord;
	WORD wPort = 8000;
	LONG userID;
 
	deviceAddress = "192.168.110.110";
	userName = "admin";
	passWord = "Xtjc.132";
 
	strcpy_s(loginInfo.sDeviceAddress, deviceAddress);
	strcpy_s(loginInfo.sUserName, userName);
	strcpy_s(loginInfo.sPassword, passWord);
	loginInfo.wPort = wPort;
 
	userID = NET_DVR_Login_V40(&loginInfo, &deviceInfo);
``` 

这里我们需要给NET_DVR_Login_V40（）函数传递两个参数且均为结构体,这时我们需要在python对NET_DVR_DEVICEINFO_V40和NET_DVR_USER_LOGIN_INFO两个类进行重写，

以NET_DVR_USER_LOGIN_INFO为例

```c++
struct{  
	char             sDeviceAddress[NET_DVR_DEV_ADDRESS_MAX_LEN];
	BYTE                    byUseTransport;
    WORD                    wPort;
	char                    sUserName[NET_DVR_LOGIN_USERNAME_MAX_LEN];
	char                    sPassword[NET_DVR_LOGIN_PASSWD_MAX_LEN];
	fLoginResultCallBack    cbLoginResult;
    void                    *pUser;
	BOOL                    bUseAsynLogin;
    BYTE                    byProxyType;
	BYTE                    byUseUTCTime; 
	BYTE                    byLoginMode;
	BYTE                    byHttps;
    LONG                    iProxyID;
	LONG                    byVerifyMode;
    BYTE                    byRes3[119];
}NET_DVR_USER_LOGIN_INFO,*LPNET_DVR_USER_LOGIN_INFO;
```

```python

class NET_DVR_USER_LOGIN_INFO(Structure):
    _fields_ = [
        ("sDeviceAddress", c_char * 129),
        ("byUseTransport", c_byte),
        ("wPort", c_uint16),
        ("sUserName", c_char * 64),
        ("sPassword", c_char * 64),
        ("bUseAsynLogin", c_int),
        ("byProxyType", c_byte),
        ("byUseUTCTime", c_byte),
        ("byLoginMode", c_byte),
        ("byHttps", c_byte),
        ("iProxyID", c_long),
        ("byVerifyMode", c_byte),
        ("byRes3", c_byte * 120)
```

对于C的数据类型转换到ctyps的一些基本数据类型![[Pasted image 20251103165746.png]]

详细内容参考[ctypes --- Python 的外部函数库 — Python 3.14.0 文档](https://docs.python.org/zh-cn/3/library/ctypes.html)

到这里就可以在python中使用登录函数了
```python
def login(Hksdk_py, url, usename, password, port=8000):
    # python的String向ctype里的c_char传递的数据需要进行bytes编码
    burl = bytes(url, "ascii")
    busename = bytes(usename, "ascii")
    bpassword = bytes(password, "ascii")
    
    # 初始化两个结构体
    login_info = NET_DVR_Login_V40.NET_DVR_USER_LOGIN_INFO()
    device_info = NET_DVR_Login_V40.NET_DVR_DEVICEINFO_V40()
    # 设置登录信息
    login_info.wPort = port
    login_info.bUseAsynLogin = 0
    login_info.sUserName = busename
    login_info.sPassword = bpassword
    login_info.sDeviceAddress = burl
 
    # 获得引用，byref基本等于c++的&符号
    param_login = byref(login_info)  # 传递的为指针则使用该种方式
    param_device = byref(device_info)
 
    # 执行NET_DVR_Login_V40函数，获取userid
    useid = Hksdk_py.NET_DVR_Login_V40(param_login, param_device)
    # 登录成功时，useid的值为0、1.....，失败时为-1
    # 可以调用NET_DVR_GetLastError查看错误码
    if useid == -1: 
        print("登录失败，错误码为{}".format(Hksdk_py.NET_DVR_GetLastError()))
    else:
        print("登录成功，用户id为{}".format(useid))
 
    return useid
```

登出：

```python
def uinit(Hksdk_py, useid):
    isOK = Hksdk_py.NET_DVR_Logout(useid)
    if isOK == -1:
        print("登出失败错误码为{}".format(Hksdk_py.NET_DVR_GetLastError()))
    else:
        print("登出成功")
    Hksdk_py.NET_DVR_Cleanup()
```