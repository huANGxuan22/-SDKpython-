
### 操作云台（控制摄像头旋转焦距等）

使用到的函数主要有两个NET_DVR_PTZControlWithSpeed_Other和NET_DVR_PTZControlWithSpeed
其中NET_DVR_PTZControlWithSpeed_Other不启用图像预览，而
NET_DVR_PTZControlWithSpeed需要启用图像预览

在C++中：
```c++
BOOL NET_DVR_PTZControlWithSpeed_Other(LONG  lUserID,LONG  lChannel,
DWORD  dwPTZCommand,DWORD  dwStop,DWORD  dwSpeed);
```
各参数意义

	- lUserID  NET_DVR_Login_V40等登录接口的返回值
	- lChannel 通道号
	- dwPTZCommand  云台控制命令，见下表
	- dwStop 云台停止动作或开始动作：0－开始；1－停止
	- dwSpeed云台控制的速度，用户按不同解码器的速度控制值设置。取值范围[1,7]

![[Pasted image 20251104094129.png]]

在python中调用该函数需要将这些参数和函数本身用ctypes重写一遍
```python
from ctypes import *

# 云台控制命令常量定义
class PTZCommand:
    LIGHT_PWRON = 2           # 接通灯光电源
    WIPER_PWRON = 3           # 接通雨刷开关
    FAN_PWRON = 4             # 接通风扇开关
    HEATER_PWRON = 5          # 接通加热器开关
    AUX_PWRON1 = 6            # 接通辅助设备开关
    AUX_PWRON2 = 7            # 接通辅助设备开关
    ZOOM_IN = 11              # 焦距变大(倍率变大)
    ZOOM_OUT = 12             # 焦距变小(倍率变小)
    FOCUS_NEAR = 13           # 焦点前调
    FOCUS_FAR = 14            # 焦点后调
    IRIS_OPEN = 15            # 光圈扩大
    IRIS_CLOSE = 16           # 光圈缩小
    TILT_UP = 21              # 云台上仰
    TILT_DOWN = 22            # 云台下俯
    PAN_LEFT = 23             # 云台左转
    PAN_RIGHT = 24            # 云台右转
    UP_LEFT = 25              # 云台上仰和左转
    UP_RIGHT = 26             # 云台上仰和右转
    DOWN_LEFT = 27            # 云台下俯和左转
    DOWN_RIGHT = 28           # 云台下俯和右转
    PAN_AUTO = 29             # 云台左右自动扫描
    TILT_DOWN_ZOOM_IN = 58    # 云台下俯和焦距变大(倍率变大)
    TILT_DOWN_ZOOM_OUT = 59   # 云台下俯和焦距变小(倍率变小)
    PAN_LEFT_ZOOM_IN = 60     # 云台左转和焦距变大(倍率变大)
    PAN_LEFT_ZOOM_OUT = 61    # 云台左转和焦距变小(倍率变小)
    PAN_RIGHT_ZOOM_IN = 62    # 云台右转和焦距变大(倍率变大)
    PAN_RIGHT_ZOOM_OUT = 63   # 云台右转和焦距变小(倍率变小)
    UP_LEFT_ZOOM_IN = 64      # 云台上仰和左转和焦距变大(倍率变大)
    UP_LEFT_ZOOM_OUT = 65     # 云台上仰和左转和焦距变小(倍率变小)
    UP_RIGHT_ZOOM_IN = 66     # 云台上仰和右转和焦距变大(倍率变大)
    UP_RIGHT_ZOOM_OUT = 67    # 云台上仰和右转和焦距变小(倍率变小)
    DOWN_LEFT_ZOOM_IN = 68    # 云台下俯和左转和焦距变大(倍率变大)
    DOWN_LEFT_ZOOM_OUT = 69   # 云台下俯和左转和焦距变小(倍率变小)
    DOWN_RIGHT_ZOOM_IN = 70   # 云台下俯和右转和焦距变大(倍率变大)
    DOWN_RIGHT_ZOOM_OUT = 71  # 云台下俯和右转和焦距变小(倍率变小)
    TILT_UP_ZOOM_IN = 72      # 云台上仰和焦距变大(倍率变大)
    TILT_UP_ZOOM_OUT = 73     # 云台上仰和焦距变小(倍率变小)

def setup_ptz_control_other(hksdk):
    """
    设置NET_DVR_PTZControlWithSpeed_Other函数的参数类型
    
    函数原型:
    BOOL NET_DVR_PTZControlWithSpeed_Other(
        LONG  lUserID,
        LONG  lChannel,
        DWORD dwPTZCommand,
        DWORD dwStop,
        DWORD dwSpeed
    );
    
    参数说明:
    lUserID: [in] NET_DVR_Login_V40等登录接口的返回值
    lChannel: [in] 通道号
    dwPTZCommand: [in] 云台控制命令，见PTZCommand类
    dwStop: [in] 云台停止动作或开始动作：0－开始；1－停止
    dwSpeed: [in] 云台控制的速度，取值范围[1,7]
    
    返回值:
    BOOL: 成功返回TRUE，失败返回FALSE
    """
    hksdk.NET_DVR_PTZControlWithSpeed_Other.argtypes = [
        c_long,    # lUserID
        c_long,    # lChannel
        c_uint,    # dwPTZCommand
        c_uint,    # dwStop
        c_uint     # dwSpeed
    ]
    hksdk.NET_DVR_PTZControlWithSpeed_Other.restype = c_bool

def ptz_control_with_speed_other(hksdk, user_id, channel, command, stop, speed):
    """
    带速度的云台控制操作(不用启动图象预览)
    
    参数:
        hksdk: SDK对象
        user_id: 登录返回的用户ID
        channel: 通道号
        command: 云台控制命令，使用PTZCommand类中的常量
        stop: 0-开始, 1-停止
        speed: 速度值 (1-7)
    
    返回:
        bool: 操作是否成功
    """
    result = hksdk.NET_DVR_PTZControlWithSpeed_Other(
        c_long(user_id),
        c_long(channel),
        c_uint(command),
        c_uint(stop),
        c_uint(speed)
    )
    
    if not result:
        error_code = hksdk.NET_DVR_GetLastError()
        print(f"云台控制失败，错误码: {error_code}")
        return False
    
    if stop == 0:
        action_str = "开始"
    else:
        action_str = "停止"
    
    command_name = get_ptz_command_name(command)
    print(f"云台控制成功: {action_str} {command_name}, 速度: {speed}, 通道: {channel}")
    return True

def get_ptz_command_name(command):
    """获取云台命令的名称"""
    command_names = {
        PTZCommand.LIGHT_PWRON: "接通灯光电源",
        PTZCommand.WIPER_PWRON: "接通雨刷开关",
        PTZCommand.FAN_PWRON: "接通风扇开关",
        PTZCommand.HEATER_PWRON: "接通加热器开关",
        PTZCommand.AUX_PWRON1: "接通辅助设备开关1",
        PTZCommand.AUX_PWRON2: "接通辅助设备开关2",
        PTZCommand.ZOOM_IN: "焦距变大(倍率变大)",
        PTZCommand.ZOOM_OUT: "焦距变小(倍率变小)",
        PTZCommand.FOCUS_NEAR: "焦点前调",
        PTZCommand.FOCUS_FAR: "焦点后调",
        PTZCommand.IRIS_OPEN: "光圈扩大",
        PTZCommand.IRIS_CLOSE: "光圈缩小",
        PTZCommand.TILT_UP: "云台上仰",
        PTZCommand.TILT_DOWN: "云台下俯",
        PTZCommand.PAN_LEFT: "云台左转",
        PTZCommand.PAN_RIGHT: "云台右转",
        PTZCommand.UP_LEFT: "云台上仰和左转",
        PTZCommand.UP_RIGHT: "云台上仰和右转",
        PTZCommand.DOWN_LEFT: "云台下俯和左转",
        PTZCommand.DOWN_RIGHT: "云台下俯和右转",
        PTZCommand.PAN_AUTO: "云台左右自动扫描"
    }
    
    return command_names.get(command, f"未知命令({command})")

# 云台控制封装类
class PTZController:
    def __init__(self, hksdk):
        self.hksdk = hksdk
        self.user_id = -1
        self.channel = 1
        self._setup_ptz_functions()
    
    def _setup_ptz_functions(self):
        """设置云台控制函数的参数类型"""
        setup_ptz_control_other(self.hksdk)
    
    def set_user_info(self, user_id, channel=1):
        """设置用户ID和通道号"""
        self.user_id = user_id
        self.channel = channel
    
    def control(self, command, stop, speed):
        """
        控制云台运动
        
        参数:
            command: 云台控制命令
            stop: 0-开始, 1-停止
            speed: 速度值 (1-7)
        
        返回:
            bool: 操作是否成功
        """
        if self.user_id == -1:
            print("错误：请先设置用户ID")
            return False
            
        return ptz_control_with_speed_other(
            self.hksdk, self.user_id, self.channel, 
            command, stop, speed
        )
    
    def move(self, direction, speed=5, duration=0):
        """
        控制云台移动（带自动停止功能）
        
        参数:
            direction: 移动方向
            speed: 移动速度 (1-7)
            duration: 持续时间(秒)，0表示不自动停止
        """
        import time
        
        # 开始移动
        success = self.control(direction, 0, speed)
        
        # 如果设置了持续时间，自动停止
        if success and duration > 0:
            time.sleep(duration)
            self.control(direction, 1, speed)
        
        return success
    
    def stop(self, direction):
        """停止云台运动"""
        return self.control(direction, 1, 0)
    
    def test_basic_movements(self):
        """测试基本云台运动功能"""
        print("开始基本云台控制测试...")
        
        movements = [
            ("右转", PTZCommand.PAN_RIGHT, 3),
            ("左转", PTZCommand.PAN_LEFT, 3),
            ("上仰", PTZCommand.TILT_UP, 2),
            ("下俯", PTZCommand.TILT_DOWN, 2),
        ]
        
        for name, command, duration in movements:
            print(f"测试: {name}...")
            if self.move(command, speed=4, duration=duration):
                print(f"{name}测试完成")
            else:
                print(f"{name}测试失败")
        
        print("基本云台控制测试完成！")
    
    def test_zoom_focus(self):
        """测试变焦和聚焦功能"""
        print("开始变焦和聚焦测试...")
        
        zoom_focus_actions = [
            ("变焦放大", PTZCommand.ZOOM_IN, 2),
            ("变焦缩小", PTZCommand.ZOOM_OUT, 2),
            ("焦点前调", PTZCommand.FOCUS_NEAR, 1),
            ("焦点后调", PTZCommand.FOCUS_FAR, 1),
        ]
        
        for name, command, duration in zoom_focus_actions:
            print(f"测试: {name}...")
            if self.move(command, speed=3, duration=duration):
                print(f"{name}测试完成")
            else:
                print(f"{name}测试失败")
        
        print("变焦和聚焦测试完成！")
    
    def test_complex_movements(self):
        """测试复合云台运动"""
        print("开始复合云台运动测试...")
        
        complex_movements = [
            ("上仰左转", PTZCommand.UP_LEFT, 2),
            ("上仰右转", PTZCommand.UP_RIGHT, 2),
            ("下俯左转", PTZCommand.DOWN_LEFT, 2),
            ("下俯右转", PTZCommand.DOWN_RIGHT, 2),
        ]
        
        for name, command, duration in complex_movements:
            print(f"测试: {name}...")
            if self.move(command, speed=3, duration=duration):
                print(f"{name}测试完成")
            else:
                print(f"{name}测试失败")
        
        print("复合云台运动测试完成！")
```

还有一个函数# NET_DVR_PTZControlWithSpeed与# NET_DVR_PTZControlWithSpeed_Other差不多，但是后者需要先启动预览，其定义为
```C++
BOOL NET_DVR_PTZControlWithSpeed(
	LONG _lRealHandle_,
	DWORD _dwPTZCommand_,
	DWORD _dwStop_,
	DWORD _dwSpeed_ );
```

可见其本身少一个lChannel 通道号，其他的调用与NET_DVR_PTZControlWithSpeed_Other相同

### 布防


以普通事件中的移动侦测举例，在登录后的配置/事件/普通事件中对需要侦测的区域绘制即可
![[Pasted image 20251104110907.png]]
布防可以用NET_DVR_SetupAlarmChan_V41（）来实现


```c++
//原型
LONG NET_DVR_SetupAlarmChan_V41(
	LONG   _lUserID_,
	[LPNET_DVR_SETUPALARM_PARAM] _lpSetupParam_);
	
//具体调用	
	NET_DVR_SETUPALARM_PARAM setupParam = { 0 };
	setupParam.dwSize = sizeof(NET_DVR_SETUPALARM_PARAM);
	setupParam.byLevel = 0; //优先级 0 高 1低
	LONG handle = NET_DVR_SetupAlarmChan_V41(userID, &setupParam);
```

在海康sdk中，当触发了报警时间后，会自动调用用户设置的回调函数，该函数原型为

```c++
BOOL CALLBACK MSesGCallback(
	LONG lCommand, 
	NET_DVR_ALARMER *pAlarmer, 
    char *pAlarmInfo, 
    DWORD dwBufLen, 
    void* pUser) ;
```

该函数除了之前提到过的普通数据类型与自定义数据类型外还有一个回调函数，故使用时需要自己写一个方法用作回调函数。

```python
@CFUNCTYPE(c_int, c_long, MSesGCallback.NET_DVR_ALARMER, POINTER(c_char), c_ulong, c_void_p)
def alarm_callback(lCommand: c_long, pAlarmer: MSesGCallback.NET_DVR_ALARMER,
                   pAlarmInfo: POINTER(c_char), dwBufLen: c_ulong, pUser: c_void_p):
    print("收到警报信息，类型为 {} \t发送者为 {}".format(lCommand, pAlarmer.lUserID))
    if lCommand == 0x4000:
        print("消息类型为 COMM_ALARM_V30", end=" --> ")
        alarm_info = ALARM.NET_DVR_ALARMINFO_V30()
        # 更正，换成POINTER(c_char)后，不需要调用decode方法
        memmove(addressof(alarm_info), pAlarmInfo, sizeof(alarm_info))
        if alarm_info.dwAlarmType == 3:
            print("子事件为移动侦测")
        else:
            print("子事件 None")
    else:
        print("消息类型为None")
 
    return 1
 
```